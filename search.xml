<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[apache24_error]]></title>
    <url>%2F2017%2F08%2F09%2Fapache24-error%2F</url>
    <content type="text"><![CDATA[Apache24连接数据库莫名卡死解决办法情况概述基于django搭建的网站，Apache24执行网站请求时，利用Python库pymssql连接数据库查询，服务器莫名卡死，服务器莫名卡死，自己找BUG找了几天，终于发现卡死的位置是pymssql连接SQL Server 2012数据库执行查询的位置。大概是数据库响应超时？但是又没有任何反馈报错，apache24失效，无法处理网站请求。需要重启才能恢复。让我不解的是，这种情况时偶发事件，多数情况可以正常执行，不知道什么时候就会卡死。在网上找了好多资料，没发现有用的。自己想了一下，加一个装饰器，数据库超时未响应直接返归错误提示，这样服务器大概不会卡死失去服务能力。于是找到了下面这些代码，至于怎么加装饰器到自己的数据库连接程序上，后面会有详细的介绍。网站配置信息是我自己的网站配置，大家可以参考一下。超时报错装饰器代码Python代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107# -*- coding: utf-8 -*-#网站配置：# Python 2.7.10# django 1.8.16# Microsoft SQL Server 2012# AppServ 8.5.0（Apache24）# pymssql 2.1.0# author：Kevin Liu 测试有效import sysimport threadingimport timeclass KThread(threading.Thread): &quot;&quot;&quot;A subclass of threading.Thread, with a kill() method. Come from: Kill a thread in Python: http://mail.python.org/pipermail/python-list/2004-May/260937.html &quot;&quot;&quot; def __init__(self, *args, **kwargs): threading.Thread.__init__(self, *args, **kwargs) self.killed = False def start(self): &quot;&quot;&quot;Start the thread.&quot;&quot;&quot; self.__run_backup = self.run self.run = self.__run # Force the Thread to install our trace. threading.Thread.start(self) def __run(self): &quot;&quot;&quot;Hacked run function, which installs the trace.&quot;&quot;&quot; sys.settrace(self.globaltrace) self.__run_backup() self.run = self.__run_backup def globaltrace(self, frame, why, arg): if why == &apos;call&apos;: return self.localtrace else: return None def localtrace(self, frame, why, arg): if self.killed: if why == &apos;line&apos;: raise SystemExit() return self.localtrace def kill(self): self.killed = Trueclass Timeout(Exception): &quot;&quot;&quot;function run timeout&quot;&quot;&quot; def timeout(seconds): &quot;&quot;&quot;超时装饰器，指定超时时间 若被装饰的方法在指定的时间内未返回，则抛出Timeout异常&quot;&quot;&quot; def timeout_decorator(func): &quot;&quot;&quot;真正的装饰器&quot;&quot;&quot; def _new_func(oldfunc, result, oldfunc_args, oldfunc_kwargs): result.append(oldfunc(*oldfunc_args, **oldfunc_kwargs)) def _(*args, **kwargs): result = [] new_kwargs = &#123; # create new args for _new_func, because we want to get the func return val to result list &apos;oldfunc&apos;: func, &apos;result&apos;: result, &apos;oldfunc_args&apos;: args, &apos;oldfunc_kwargs&apos;: kwargs &#125; thd = KThread(target=_new_func, args=(), kwargs=new_kwargs) thd.start() thd.join(seconds alive = thd.isAlive() thd.kill() # kill the child thread if alive: raise Timeout(u&apos;function run too long, timeout %d seconds.&apos; % seconds) else: return result[0] _.__name__ = func.__name__ _.__doc__ = func.__doc__ return _ return timeout_decorator#*********************************************#测试功能用@timeout(5)def method_timeout(seconds, text): print &apos;start&apos;, seconds, text time.sleep(seconds) print &apos;finish&apos;, seconds, text return secondsif __name__ == &apos;__main__&apos;: for sec in range(1, 10): try: print &apos;*&apos; * 20 method_timeout(sec, &apos;test waiting %d seconds&apos; % sec) except Timeout, e: print e 不懂装饰器的使用的话，去看一下相关的介绍吧。数据库文件代码Python代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# -*- coding: utf-8 -*-# author：Kevin Liu# 配置信息同上import pymssqlfrom online.timeout_deco import timeoutfrom online import user_passworddbo_user,dbo_password = user_password.get_user_password()class MSSQL: def __init__(self,host,user,pwd,db): self.host = host self.user = user self.pwd = pwd self.db = db # 这是我加装饰器的位置。每次执行数据库操作都会经过此位置 # 你也可以在调用的时候加，那样可以精确控制每个函数执行的超时时间阈值。 # 0.5代表0.5秒内没有返回查询结果，则抛出异常。 # 我没有具体测试卡住的位置是__GetConnect、ExecQuery还是ExecNonQuery，于是就都加了。 @timeout(0.5) def __GetConnect(self): if not self.db: raise(NameError,&quot;没有设置数据库信息&quot;) self.conn = pymssql.connect(host=self.host,user=self.user,password=self.pwd,database=self.db,charset=&quot;utf8&quot;) cur = self.conn.cursor() if not cur: raise(NameError,&quot;连接数据库失败&quot;) else: return cur @timeout(3) def ExecQuery(self,sql): cur = self.__GetConnect() cur.execute(sql) resList = cur.fetchall() self.conn.close() return resList @timeout(0.5) def ExecNonQuery(self,sql): cur = self.__GetConnect() cur.execute(sql) self.conn.commit() self.conn.close()#*************************************************************************def delete_bind_id(user_id): ms = MSSQL(host=&quot;localhost&quot;,user=&quot;%s&quot;%dbo_user,pwd=&quot;%s&quot;%dbo_password,db=&quot;xuanke&quot;) ms.ExecNonQuery(&quot;update user_info set bind_id =null,gra=null,maj=null,COL_RATING=null,spare_time=null where user_id = %d&quot;%user_id) delete_spare_time(user_id)if __name__ == &apos;__main__&apos;: # 如果按照上面设置以后，执行下面的语句时 # 会调用MSSQL类中的函数，所以都会受到@timeout(0.5)的约束 delete_bind_id(user_id) 测试效果使用了上面的超时装饰器@timeout()以后，如果查询结果及时返回，则Apache24继续执行请求内容。如果查询超时，则会抛出错误信息。1raise Timeout(u&apos;function run too long, timeout %d seconds.&apos; % seconds) 当项目settings 中debug = False时，Apache24处理超时信息时会显示SERVER ERROR页面，不会卡死。使用半个多月了，网站没有再发生过卡死现象。希望这些可以帮到你。]]></content>
      <categories>
        <category>程序错误解决方案</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Apache24</tag>
        <tag>Pymssql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念：2016年12月6日勇士大胜步行者]]></title>
    <url>%2F2017%2F08%2F08%2Fcelebrate-12-6%2F</url>
    <content type="text"><![CDATA[一时也想不到一个可以概括我要写的内容的题目，何况到底要写什么到现在为止还只是一个大概的印象。总的来说，就是在看完比赛后，想把脑海中浮现的种种想法用文字写下来，纪念一下。 上次写关于勇士的文字还是总决赛G7赛后，虽然已经过去很久，但那一天的画面还是不时的浮现在眼前。可以说，那场决赛失利我会永远铭记。毕竟之前的一整个赛季，一个华丽的赛季，一个充满期待，挑战，惊喜的赛季，一个本该完美无瑕的赛季，随着最后时刻欧文的三分，蒙上了一层永远都无法褪去的阴霾。 我永远都无法想象，也不敢想象，那样的一个最接近完美的时刻，真的还可以再来一次吗？纵然世界总是充满惊喜，但我真的不奢望。 经历了一次总决赛的洗礼，经历了休赛期人员调整，勇士还是我喜欢的那支勇士。他们打球的风格没有改变，团队，信任，欢乐还是一如既往。当然，跟以前不同，现在有了杜兰特，一个神一样稳定的男人。 还记得得知阿杜决定加盟勇士的那一刻，我正在和舍友们从北门撸串回来的路上，当时的一切，同样历历在目。那时我的心里由衷的喜悦，我当时还说，“下一个赛季，联盟再也没有一个球队能阻挡勇士了！” 对于阿杜来勇士，网络上有支持的，当然也有讥讽叫骂的。我当然听说过詹皇抱大腿的传说，也知道，巨星的这种决定，必然有人支持，有人反对。作为勇士球迷，我的立场就不用说了。但有一点我想说，杜兰特的这个决定以及他面对随之而来的一切的态度，让我对他由衷的敬佩。追求自己想要的生活，享受篮球的快乐，而不是被道德胁迫，做自己不喜欢做的事，明明不开心，还要装作乐在其中。 对于这个赛季的其他人员调整，我也有一些看法。扎扎和博古特相比，我显然更喜欢博古特。就目前的比赛来看，扎扎只有在策应球上，符合我的期待。像什么防守，盖帽，速度……与之相比，我倒是挺喜欢麦基，虽然他智商有点捉急，但毕竟能跳啊！跳起来就是一个空姐扣篮，跳起来就是一个盖帽，跳起来就是一个……干扰球，还时不时替对手发个球……哈哈，兼职一个活宝。希望他能再专注一点，利用好自身优势，撑起勇士内线，哪怕就一会儿。韦斯特感觉没什么可说的，毕竟老将，比较沉稳，有经验，但跟一哥和利文斯顿比，还是差那么一点。好在防守还可以。克拉克这一个赛季挺亮眼，正式成为库里的替补，小伙子也挺争气。就目前的比赛来兰，进攻能力还是不错，而且三分出手快，估计没少跟库里学。垃圾时间阵容里，他就是第一得分点了。麦考还是嫩了一点，虽然凭借季前赛的出色发挥赢得了替补出场时间，但感觉太急躁，基本功不太扎实，估计还得再磨练一两年，再来担当大任。]]></content>
      <categories>
        <category>NBA观赛感受</category>
      </categories>
      <tags>
        <tag>warriors</tag>
        <tag>victory</tag>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客测试]]></title>
    <url>%2F2017%2F08%2F08%2Fmy-new-post%2F</url>
    <content type="text"><![CDATA[欢迎使用全新的有道云笔记——— 记录工作和生活点滴，办公文档随身携带 您可以在这里1、新建笔记，在笔记中输入文字内容，插入图片、表格、附件，随时随地记录身边点滴2、上传办公文档，直接在有道云笔记内管理、查看和编辑各类Office、PDF文档3、自动实时备份，有道云笔记将您的宝贵数据实时同步到云端，永久留存4、多平台信息同步，通过电脑、手机、网页随时随地查看和编辑您的文档资料点击尝试网页版、手机版等更多版本]]></content>
      <categories>
        <category>有道云笔记</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>youdao</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
